cleanup: optimize mkstring()

A few simple changes here:

- call memset() instead of repeatedly calling strcat() on the
  target string
- use shift_string_right() for CENTER (same is already used for
  right RJUST)
- use memset() in shift_string_right()
- remove the (no longer needed) local buffer, which makes it
  possible to call mkstring() on an arbitrarily long string

Signed-off-by: Petr Tesarik <ptesarik@suse.cz>

---
 tools.c |   28 ++++++++++------------------
 1 file changed, 10 insertions(+), 18 deletions(-)

--- a/tools.c
+++ b/tools.c
@@ -1526,7 +1526,6 @@ shift_string_left(char *s, int cnt)
 char *
 shift_string_right(char *s, int cnt)
 {
-	int i;
         int origlen;
 
 	if (!cnt)
@@ -1534,12 +1533,8 @@ shift_string_right(char *s, int cnt)
 
         origlen = strlen(s);
         memmove(s+cnt, s, origlen);
-        *(s+(origlen+cnt)) = NULLCHAR;
-
-	for (i = 0; i < cnt; i++)
-		s[i] = ' ';
-
-        return(s);
+        s[origlen+cnt] = NULLCHAR;
+	return(memset(s, ' ', cnt));
 }
 
 /*
@@ -1558,7 +1553,6 @@ mkstring(char *s, int size, ulong flags,
 	int extra;
 	int left;
 	int right;
-	char buf[BUFSIZE];
 
 	switch (flags & (LONG_DEC|LONG_HEX|INT_HEX|INT_DEC|LONGLONG_HEX|ZERO_FILL)) 
 	{
@@ -1623,21 +1617,19 @@ mkstring(char *s, int size, ulong flags,
 		}
 		else 
 			left = right = extra/2;
+
+		shift_string_right(s, left);
+		len = strlen(s);
+		memset(s + len, ' ', right);
+		s[len + right] = NULLCHAR;
 	
-		bzero(buf, BUFSIZE);
-		for (i = 0; i < left; i++)
-			strcat(buf, " ");
-		strcat(buf, s);
-		for (i = 0; i < right; i++)
-			strcat(buf, " ");
-	
-		strcpy(s, buf);
 		return(s);
 	}
 
 	if (flags & LJUST) {
-		for (i = 0; i < extra; i++)
-			strcat(s, " ");
+		len = strlen(s);
+		memset(s + len, ' ', extra);
+		s[len + extra] = NULLCHAR;
 	} else if (flags & RJUST) 
 		shift_string_right(s, extra);
 
